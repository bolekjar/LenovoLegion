// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: NvidiaNvml.proto
// Protobuf C++ Version: 6.33.1

#ifndef NvidiaNvml_2eproto_2epb_2eh
#define NvidiaNvml_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_NvidiaNvml_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_NvidiaNvml_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_NvidiaNvml_2eproto;
}  // extern "C"
namespace legion {
namespace messages {
class NvidiaNvml;
struct NvidiaNvmlDefaultTypeInternal;
extern NvidiaNvmlDefaultTypeInternal _NvidiaNvml_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_class_data_;
class NvidiaNvml_HardwareMonitor;
struct NvidiaNvml_HardwareMonitorDefaultTypeInternal;
extern NvidiaNvml_HardwareMonitorDefaultTypeInternal _NvidiaNvml_HardwareMonitor_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_HardwareMonitor_class_data_;
class NvidiaNvml_HardwareMonitor_MemoryUse;
struct NvidiaNvml_HardwareMonitor_MemoryUseDefaultTypeInternal;
extern NvidiaNvml_HardwareMonitor_MemoryUseDefaultTypeInternal _NvidiaNvml_HardwareMonitor_MemoryUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_HardwareMonitor_MemoryUse_class_data_;
class NvidiaNvml_HardwareMonitor_MinMaxValue;
struct NvidiaNvml_HardwareMonitor_MinMaxValueDefaultTypeInternal;
extern NvidiaNvml_HardwareMonitor_MinMaxValueDefaultTypeInternal _NvidiaNvml_HardwareMonitor_MinMaxValue_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_HardwareMonitor_MinMaxValue_class_data_;
class NvidiaNvml_HardwareMonitor_PCIe;
struct NvidiaNvml_HardwareMonitor_PCIeDefaultTypeInternal;
extern NvidiaNvml_HardwareMonitor_PCIeDefaultTypeInternal _NvidiaNvml_HardwareMonitor_PCIe_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_HardwareMonitor_PCIe_class_data_;
class NvidiaNvml_HardwareMonitor_Power;
struct NvidiaNvml_HardwareMonitor_PowerDefaultTypeInternal;
extern NvidiaNvml_HardwareMonitor_PowerDefaultTypeInternal _NvidiaNvml_HardwareMonitor_Power_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_HardwareMonitor_Power_class_data_;
class NvidiaNvml_HardwareMonitor_Temperature;
struct NvidiaNvml_HardwareMonitor_TemperatureDefaultTypeInternal;
extern NvidiaNvml_HardwareMonitor_TemperatureDefaultTypeInternal _NvidiaNvml_HardwareMonitor_Temperature_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_HardwareMonitor_Temperature_class_data_;
class NvidiaNvml_OffsetSettings;
struct NvidiaNvml_OffsetSettingsDefaultTypeInternal;
extern NvidiaNvml_OffsetSettingsDefaultTypeInternal _NvidiaNvml_OffsetSettings_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_OffsetSettings_class_data_;
}  // namespace messages
}  // namespace legion
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace legion {
namespace messages {

// ===================================================================


// -------------------------------------------------------------------

class NvidiaNvml_OffsetSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:legion.messages.NvidiaNvml.OffsetSettings) */ {
 public:
  inline NvidiaNvml_OffsetSettings() : NvidiaNvml_OffsetSettings(nullptr) {}
  ~NvidiaNvml_OffsetSettings() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NvidiaNvml_OffsetSettings* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NvidiaNvml_OffsetSettings));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NvidiaNvml_OffsetSettings(::google::protobuf::internal::ConstantInitialized);

  inline NvidiaNvml_OffsetSettings(const NvidiaNvml_OffsetSettings& from) : NvidiaNvml_OffsetSettings(nullptr, from) {}
  inline NvidiaNvml_OffsetSettings(NvidiaNvml_OffsetSettings&& from) noexcept
      : NvidiaNvml_OffsetSettings(nullptr, ::std::move(from)) {}
  inline NvidiaNvml_OffsetSettings& operator=(const NvidiaNvml_OffsetSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvidiaNvml_OffsetSettings& operator=(NvidiaNvml_OffsetSettings&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvidiaNvml_OffsetSettings& default_instance() {
    return *reinterpret_cast<const NvidiaNvml_OffsetSettings*>(
        &_NvidiaNvml_OffsetSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(NvidiaNvml_OffsetSettings& a, NvidiaNvml_OffsetSettings& b) { a.Swap(&b); }
  inline void Swap(NvidiaNvml_OffsetSettings* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvidiaNvml_OffsetSettings* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvidiaNvml_OffsetSettings* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NvidiaNvml_OffsetSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NvidiaNvml_OffsetSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NvidiaNvml_OffsetSettings& from) { NvidiaNvml_OffsetSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NvidiaNvml_OffsetSettings* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "legion.messages.NvidiaNvml.OffsetSettings"; }

  explicit NvidiaNvml_OffsetSettings(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NvidiaNvml_OffsetSettings(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NvidiaNvml_OffsetSettings& from);
  NvidiaNvml_OffsetSettings(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NvidiaNvml_OffsetSettings&& from) noexcept
      : NvidiaNvml_OffsetSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMaxFieldNumber = 1,
    kMinFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // uint32 max = 1;
  bool has_max() const;
  void clear_max() ;
  ::uint32_t max() const;
  void set_max(::uint32_t value);

  private:
  ::uint32_t _internal_max() const;
  void _internal_set_max(::uint32_t value);

  public:
  // uint32 min = 2;
  bool has_min() const;
  void clear_min() ;
  ::uint32_t min() const;
  void set_min(::uint32_t value);

  private:
  ::uint32_t _internal_min() const;
  void _internal_set_min(::uint32_t value);

  public:
  // int32 value = 3;
  bool has_value() const;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:legion.messages.NvidiaNvml.OffsetSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NvidiaNvml_OffsetSettings& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t max_;
    ::uint32_t min_;
    ::int32_t value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_NvidiaNvml_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_OffsetSettings_class_data_;
// -------------------------------------------------------------------

class NvidiaNvml_HardwareMonitor_Temperature final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:legion.messages.NvidiaNvml.HardwareMonitor.Temperature) */ {
 public:
  inline NvidiaNvml_HardwareMonitor_Temperature() : NvidiaNvml_HardwareMonitor_Temperature(nullptr) {}
  ~NvidiaNvml_HardwareMonitor_Temperature() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NvidiaNvml_HardwareMonitor_Temperature));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NvidiaNvml_HardwareMonitor_Temperature(::google::protobuf::internal::ConstantInitialized);

  inline NvidiaNvml_HardwareMonitor_Temperature(const NvidiaNvml_HardwareMonitor_Temperature& from) : NvidiaNvml_HardwareMonitor_Temperature(nullptr, from) {}
  inline NvidiaNvml_HardwareMonitor_Temperature(NvidiaNvml_HardwareMonitor_Temperature&& from) noexcept
      : NvidiaNvml_HardwareMonitor_Temperature(nullptr, ::std::move(from)) {}
  inline NvidiaNvml_HardwareMonitor_Temperature& operator=(const NvidiaNvml_HardwareMonitor_Temperature& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvidiaNvml_HardwareMonitor_Temperature& operator=(NvidiaNvml_HardwareMonitor_Temperature&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvidiaNvml_HardwareMonitor_Temperature& default_instance() {
    return *reinterpret_cast<const NvidiaNvml_HardwareMonitor_Temperature*>(
        &_NvidiaNvml_HardwareMonitor_Temperature_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(NvidiaNvml_HardwareMonitor_Temperature& a, NvidiaNvml_HardwareMonitor_Temperature& b) { a.Swap(&b); }
  inline void Swap(NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NvidiaNvml_HardwareMonitor_Temperature>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NvidiaNvml_HardwareMonitor_Temperature& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NvidiaNvml_HardwareMonitor_Temperature& from) { NvidiaNvml_HardwareMonitor_Temperature::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "legion.messages.NvidiaNvml.HardwareMonitor.Temperature"; }

  explicit NvidiaNvml_HardwareMonitor_Temperature(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NvidiaNvml_HardwareMonitor_Temperature(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NvidiaNvml_HardwareMonitor_Temperature& from);
  NvidiaNvml_HardwareMonitor_Temperature(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NvidiaNvml_HardwareMonitor_Temperature&& from) noexcept
      : NvidiaNvml_HardwareMonitor_Temperature(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kSlowdownFieldNumber = 3,
    kShutdownFieldNumber = 4,
  };
  // uint32 value = 1;
  bool has_value() const;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // uint32 slowdown = 3;
  bool has_slowdown() const;
  void clear_slowdown() ;
  ::uint32_t slowdown() const;
  void set_slowdown(::uint32_t value);

  private:
  ::uint32_t _internal_slowdown() const;
  void _internal_set_slowdown(::uint32_t value);

  public:
  // uint32 shutdown = 4;
  bool has_shutdown() const;
  void clear_shutdown() ;
  ::uint32_t shutdown() const;
  void set_shutdown(::uint32_t value);

  private:
  ::uint32_t _internal_shutdown() const;
  void _internal_set_shutdown(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:legion.messages.NvidiaNvml.HardwareMonitor.Temperature)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NvidiaNvml_HardwareMonitor_Temperature& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t value_;
    ::uint32_t slowdown_;
    ::uint32_t shutdown_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_NvidiaNvml_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_HardwareMonitor_Temperature_class_data_;
// -------------------------------------------------------------------

class NvidiaNvml_HardwareMonitor_Power final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:legion.messages.NvidiaNvml.HardwareMonitor.Power) */ {
 public:
  inline NvidiaNvml_HardwareMonitor_Power() : NvidiaNvml_HardwareMonitor_Power(nullptr) {}
  ~NvidiaNvml_HardwareMonitor_Power() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NvidiaNvml_HardwareMonitor_Power));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NvidiaNvml_HardwareMonitor_Power(::google::protobuf::internal::ConstantInitialized);

  inline NvidiaNvml_HardwareMonitor_Power(const NvidiaNvml_HardwareMonitor_Power& from) : NvidiaNvml_HardwareMonitor_Power(nullptr, from) {}
  inline NvidiaNvml_HardwareMonitor_Power(NvidiaNvml_HardwareMonitor_Power&& from) noexcept
      : NvidiaNvml_HardwareMonitor_Power(nullptr, ::std::move(from)) {}
  inline NvidiaNvml_HardwareMonitor_Power& operator=(const NvidiaNvml_HardwareMonitor_Power& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvidiaNvml_HardwareMonitor_Power& operator=(NvidiaNvml_HardwareMonitor_Power&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvidiaNvml_HardwareMonitor_Power& default_instance() {
    return *reinterpret_cast<const NvidiaNvml_HardwareMonitor_Power*>(
        &_NvidiaNvml_HardwareMonitor_Power_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(NvidiaNvml_HardwareMonitor_Power& a, NvidiaNvml_HardwareMonitor_Power& b) { a.Swap(&b); }
  inline void Swap(NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NvidiaNvml_HardwareMonitor_Power>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NvidiaNvml_HardwareMonitor_Power& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NvidiaNvml_HardwareMonitor_Power& from) { NvidiaNvml_HardwareMonitor_Power::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "legion.messages.NvidiaNvml.HardwareMonitor.Power"; }

  explicit NvidiaNvml_HardwareMonitor_Power(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NvidiaNvml_HardwareMonitor_Power(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NvidiaNvml_HardwareMonitor_Power& from);
  NvidiaNvml_HardwareMonitor_Power(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NvidiaNvml_HardwareMonitor_Power&& from) noexcept
      : NvidiaNvml_HardwareMonitor_Power(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kMinValueFieldNumber = 2,
    kMaxValueFieldNumber = 3,
    kDefaultValueFieldNumber = 4,
    kTotalFieldNumber = 6,
    kEnforcedValueFieldNumber = 5,
  };
  // uint32 value = 1;
  bool has_value() const;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // uint32 min_value = 2;
  bool has_min_value() const;
  void clear_min_value() ;
  ::uint32_t min_value() const;
  void set_min_value(::uint32_t value);

  private:
  ::uint32_t _internal_min_value() const;
  void _internal_set_min_value(::uint32_t value);

  public:
  // uint32 max_value = 3;
  bool has_max_value() const;
  void clear_max_value() ;
  ::uint32_t max_value() const;
  void set_max_value(::uint32_t value);

  private:
  ::uint32_t _internal_max_value() const;
  void _internal_set_max_value(::uint32_t value);

  public:
  // uint32 default_value = 4;
  bool has_default_value() const;
  void clear_default_value() ;
  ::uint32_t default_value() const;
  void set_default_value(::uint32_t value);

  private:
  ::uint32_t _internal_default_value() const;
  void _internal_set_default_value(::uint32_t value);

  public:
  // uint64 total = 6;
  bool has_total() const;
  void clear_total() ;
  ::uint64_t total() const;
  void set_total(::uint64_t value);

  private:
  ::uint64_t _internal_total() const;
  void _internal_set_total(::uint64_t value);

  public:
  // uint32 enforced_value = 5;
  bool has_enforced_value() const;
  void clear_enforced_value() ;
  ::uint32_t enforced_value() const;
  void set_enforced_value(::uint32_t value);

  private:
  ::uint32_t _internal_enforced_value() const;
  void _internal_set_enforced_value(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:legion.messages.NvidiaNvml.HardwareMonitor.Power)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NvidiaNvml_HardwareMonitor_Power& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t value_;
    ::uint32_t min_value_;
    ::uint32_t max_value_;
    ::uint32_t default_value_;
    ::uint64_t total_;
    ::uint32_t enforced_value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_NvidiaNvml_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_HardwareMonitor_Power_class_data_;
// -------------------------------------------------------------------

class NvidiaNvml_HardwareMonitor_PCIe final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:legion.messages.NvidiaNvml.HardwareMonitor.PCIe) */ {
 public:
  inline NvidiaNvml_HardwareMonitor_PCIe() : NvidiaNvml_HardwareMonitor_PCIe(nullptr) {}
  ~NvidiaNvml_HardwareMonitor_PCIe() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NvidiaNvml_HardwareMonitor_PCIe));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NvidiaNvml_HardwareMonitor_PCIe(::google::protobuf::internal::ConstantInitialized);

  inline NvidiaNvml_HardwareMonitor_PCIe(const NvidiaNvml_HardwareMonitor_PCIe& from) : NvidiaNvml_HardwareMonitor_PCIe(nullptr, from) {}
  inline NvidiaNvml_HardwareMonitor_PCIe(NvidiaNvml_HardwareMonitor_PCIe&& from) noexcept
      : NvidiaNvml_HardwareMonitor_PCIe(nullptr, ::std::move(from)) {}
  inline NvidiaNvml_HardwareMonitor_PCIe& operator=(const NvidiaNvml_HardwareMonitor_PCIe& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvidiaNvml_HardwareMonitor_PCIe& operator=(NvidiaNvml_HardwareMonitor_PCIe&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvidiaNvml_HardwareMonitor_PCIe& default_instance() {
    return *reinterpret_cast<const NvidiaNvml_HardwareMonitor_PCIe*>(
        &_NvidiaNvml_HardwareMonitor_PCIe_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(NvidiaNvml_HardwareMonitor_PCIe& a, NvidiaNvml_HardwareMonitor_PCIe& b) { a.Swap(&b); }
  inline void Swap(NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NvidiaNvml_HardwareMonitor_PCIe>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NvidiaNvml_HardwareMonitor_PCIe& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NvidiaNvml_HardwareMonitor_PCIe& from) { NvidiaNvml_HardwareMonitor_PCIe::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "legion.messages.NvidiaNvml.HardwareMonitor.PCIe"; }

  explicit NvidiaNvml_HardwareMonitor_PCIe(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NvidiaNvml_HardwareMonitor_PCIe(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NvidiaNvml_HardwareMonitor_PCIe& from);
  NvidiaNvml_HardwareMonitor_PCIe(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NvidiaNvml_HardwareMonitor_PCIe&& from) noexcept
      : NvidiaNvml_HardwareMonitor_PCIe(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGenerationFieldNumber = 1,
    kGenerationMaxFieldNumber = 2,
    kWidthFieldNumber = 3,
    kWidthMaxFieldNumber = 4,
    kRxBytesFieldNumber = 5,
    kTxBytesFieldNumber = 6,
  };
  // uint32 generation = 1;
  bool has_generation() const;
  void clear_generation() ;
  ::uint32_t generation() const;
  void set_generation(::uint32_t value);

  private:
  ::uint32_t _internal_generation() const;
  void _internal_set_generation(::uint32_t value);

  public:
  // uint32 generation_max = 2;
  bool has_generation_max() const;
  void clear_generation_max() ;
  ::uint32_t generation_max() const;
  void set_generation_max(::uint32_t value);

  private:
  ::uint32_t _internal_generation_max() const;
  void _internal_set_generation_max(::uint32_t value);

  public:
  // uint32 width = 3;
  bool has_width() const;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // uint32 width_max = 4;
  bool has_width_max() const;
  void clear_width_max() ;
  ::uint32_t width_max() const;
  void set_width_max(::uint32_t value);

  private:
  ::uint32_t _internal_width_max() const;
  void _internal_set_width_max(::uint32_t value);

  public:
  // uint64 rx_bytes = 5;
  bool has_rx_bytes() const;
  void clear_rx_bytes() ;
  ::uint64_t rx_bytes() const;
  void set_rx_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_rx_bytes() const;
  void _internal_set_rx_bytes(::uint64_t value);

  public:
  // uint64 tx_bytes = 6;
  bool has_tx_bytes() const;
  void clear_tx_bytes() ;
  ::uint64_t tx_bytes() const;
  void set_tx_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_tx_bytes() const;
  void _internal_set_tx_bytes(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:legion.messages.NvidiaNvml.HardwareMonitor.PCIe)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NvidiaNvml_HardwareMonitor_PCIe& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t generation_;
    ::uint32_t generation_max_;
    ::uint32_t width_;
    ::uint32_t width_max_;
    ::uint64_t rx_bytes_;
    ::uint64_t tx_bytes_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_NvidiaNvml_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_HardwareMonitor_PCIe_class_data_;
// -------------------------------------------------------------------

class NvidiaNvml_HardwareMonitor_MinMaxValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue) */ {
 public:
  inline NvidiaNvml_HardwareMonitor_MinMaxValue() : NvidiaNvml_HardwareMonitor_MinMaxValue(nullptr) {}
  ~NvidiaNvml_HardwareMonitor_MinMaxValue() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NvidiaNvml_HardwareMonitor_MinMaxValue));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NvidiaNvml_HardwareMonitor_MinMaxValue(::google::protobuf::internal::ConstantInitialized);

  inline NvidiaNvml_HardwareMonitor_MinMaxValue(const NvidiaNvml_HardwareMonitor_MinMaxValue& from) : NvidiaNvml_HardwareMonitor_MinMaxValue(nullptr, from) {}
  inline NvidiaNvml_HardwareMonitor_MinMaxValue(NvidiaNvml_HardwareMonitor_MinMaxValue&& from) noexcept
      : NvidiaNvml_HardwareMonitor_MinMaxValue(nullptr, ::std::move(from)) {}
  inline NvidiaNvml_HardwareMonitor_MinMaxValue& operator=(const NvidiaNvml_HardwareMonitor_MinMaxValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvidiaNvml_HardwareMonitor_MinMaxValue& operator=(NvidiaNvml_HardwareMonitor_MinMaxValue&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvidiaNvml_HardwareMonitor_MinMaxValue& default_instance() {
    return *reinterpret_cast<const NvidiaNvml_HardwareMonitor_MinMaxValue*>(
        &_NvidiaNvml_HardwareMonitor_MinMaxValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(NvidiaNvml_HardwareMonitor_MinMaxValue& a, NvidiaNvml_HardwareMonitor_MinMaxValue& b) { a.Swap(&b); }
  inline void Swap(NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NvidiaNvml_HardwareMonitor_MinMaxValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NvidiaNvml_HardwareMonitor_MinMaxValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NvidiaNvml_HardwareMonitor_MinMaxValue& from) { NvidiaNvml_HardwareMonitor_MinMaxValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue"; }

  explicit NvidiaNvml_HardwareMonitor_MinMaxValue(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NvidiaNvml_HardwareMonitor_MinMaxValue(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NvidiaNvml_HardwareMonitor_MinMaxValue& from);
  NvidiaNvml_HardwareMonitor_MinMaxValue(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NvidiaNvml_HardwareMonitor_MinMaxValue&& from) noexcept
      : NvidiaNvml_HardwareMonitor_MinMaxValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kMinValueFieldNumber = 2,
    kMaxValueFieldNumber = 3,
  };
  // uint32 value = 1;
  bool has_value() const;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // uint32 min_value = 2;
  bool has_min_value() const;
  void clear_min_value() ;
  ::uint32_t min_value() const;
  void set_min_value(::uint32_t value);

  private:
  ::uint32_t _internal_min_value() const;
  void _internal_set_min_value(::uint32_t value);

  public:
  // uint32 max_value = 3;
  bool has_max_value() const;
  void clear_max_value() ;
  ::uint32_t max_value() const;
  void set_max_value(::uint32_t value);

  private:
  ::uint32_t _internal_max_value() const;
  void _internal_set_max_value(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NvidiaNvml_HardwareMonitor_MinMaxValue& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t value_;
    ::uint32_t min_value_;
    ::uint32_t max_value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_NvidiaNvml_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_HardwareMonitor_MinMaxValue_class_data_;
// -------------------------------------------------------------------

class NvidiaNvml_HardwareMonitor_MemoryUse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:legion.messages.NvidiaNvml.HardwareMonitor.MemoryUse) */ {
 public:
  inline NvidiaNvml_HardwareMonitor_MemoryUse() : NvidiaNvml_HardwareMonitor_MemoryUse(nullptr) {}
  ~NvidiaNvml_HardwareMonitor_MemoryUse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NvidiaNvml_HardwareMonitor_MemoryUse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NvidiaNvml_HardwareMonitor_MemoryUse(::google::protobuf::internal::ConstantInitialized);

  inline NvidiaNvml_HardwareMonitor_MemoryUse(const NvidiaNvml_HardwareMonitor_MemoryUse& from) : NvidiaNvml_HardwareMonitor_MemoryUse(nullptr, from) {}
  inline NvidiaNvml_HardwareMonitor_MemoryUse(NvidiaNvml_HardwareMonitor_MemoryUse&& from) noexcept
      : NvidiaNvml_HardwareMonitor_MemoryUse(nullptr, ::std::move(from)) {}
  inline NvidiaNvml_HardwareMonitor_MemoryUse& operator=(const NvidiaNvml_HardwareMonitor_MemoryUse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvidiaNvml_HardwareMonitor_MemoryUse& operator=(NvidiaNvml_HardwareMonitor_MemoryUse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvidiaNvml_HardwareMonitor_MemoryUse& default_instance() {
    return *reinterpret_cast<const NvidiaNvml_HardwareMonitor_MemoryUse*>(
        &_NvidiaNvml_HardwareMonitor_MemoryUse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(NvidiaNvml_HardwareMonitor_MemoryUse& a, NvidiaNvml_HardwareMonitor_MemoryUse& b) { a.Swap(&b); }
  inline void Swap(NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NvidiaNvml_HardwareMonitor_MemoryUse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NvidiaNvml_HardwareMonitor_MemoryUse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NvidiaNvml_HardwareMonitor_MemoryUse& from) { NvidiaNvml_HardwareMonitor_MemoryUse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "legion.messages.NvidiaNvml.HardwareMonitor.MemoryUse"; }

  explicit NvidiaNvml_HardwareMonitor_MemoryUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NvidiaNvml_HardwareMonitor_MemoryUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NvidiaNvml_HardwareMonitor_MemoryUse& from);
  NvidiaNvml_HardwareMonitor_MemoryUse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NvidiaNvml_HardwareMonitor_MemoryUse&& from) noexcept
      : NvidiaNvml_HardwareMonitor_MemoryUse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUsedFieldNumber = 1,
    kTotalFieldNumber = 2,
    kFreeFieldNumber = 3,
  };
  // uint64 used = 1;
  bool has_used() const;
  void clear_used() ;
  ::uint64_t used() const;
  void set_used(::uint64_t value);

  private:
  ::uint64_t _internal_used() const;
  void _internal_set_used(::uint64_t value);

  public:
  // uint64 total = 2;
  bool has_total() const;
  void clear_total() ;
  ::uint64_t total() const;
  void set_total(::uint64_t value);

  private:
  ::uint64_t _internal_total() const;
  void _internal_set_total(::uint64_t value);

  public:
  // uint64 free = 3;
  bool has_free() const;
  void clear_free() ;
  ::uint64_t free() const;
  void set_free(::uint64_t value);

  private:
  ::uint64_t _internal_free() const;
  void _internal_set_free(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:legion.messages.NvidiaNvml.HardwareMonitor.MemoryUse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NvidiaNvml_HardwareMonitor_MemoryUse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t used_;
    ::uint64_t total_;
    ::uint64_t free_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_NvidiaNvml_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_HardwareMonitor_MemoryUse_class_data_;
// -------------------------------------------------------------------

class NvidiaNvml_HardwareMonitor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:legion.messages.NvidiaNvml.HardwareMonitor) */ {
 public:
  inline NvidiaNvml_HardwareMonitor() : NvidiaNvml_HardwareMonitor(nullptr) {}
  ~NvidiaNvml_HardwareMonitor() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NvidiaNvml_HardwareMonitor* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NvidiaNvml_HardwareMonitor));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NvidiaNvml_HardwareMonitor(::google::protobuf::internal::ConstantInitialized);

  inline NvidiaNvml_HardwareMonitor(const NvidiaNvml_HardwareMonitor& from) : NvidiaNvml_HardwareMonitor(nullptr, from) {}
  inline NvidiaNvml_HardwareMonitor(NvidiaNvml_HardwareMonitor&& from) noexcept
      : NvidiaNvml_HardwareMonitor(nullptr, ::std::move(from)) {}
  inline NvidiaNvml_HardwareMonitor& operator=(const NvidiaNvml_HardwareMonitor& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvidiaNvml_HardwareMonitor& operator=(NvidiaNvml_HardwareMonitor&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvidiaNvml_HardwareMonitor& default_instance() {
    return *reinterpret_cast<const NvidiaNvml_HardwareMonitor*>(
        &_NvidiaNvml_HardwareMonitor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(NvidiaNvml_HardwareMonitor& a, NvidiaNvml_HardwareMonitor& b) { a.Swap(&b); }
  inline void Swap(NvidiaNvml_HardwareMonitor* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvidiaNvml_HardwareMonitor* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvidiaNvml_HardwareMonitor* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NvidiaNvml_HardwareMonitor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NvidiaNvml_HardwareMonitor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NvidiaNvml_HardwareMonitor& from) { NvidiaNvml_HardwareMonitor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NvidiaNvml_HardwareMonitor* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "legion.messages.NvidiaNvml.HardwareMonitor"; }

  explicit NvidiaNvml_HardwareMonitor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NvidiaNvml_HardwareMonitor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NvidiaNvml_HardwareMonitor& from);
  NvidiaNvml_HardwareMonitor(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NvidiaNvml_HardwareMonitor&& from) noexcept
      : NvidiaNvml_HardwareMonitor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using MinMaxValue = NvidiaNvml_HardwareMonitor_MinMaxValue;
  using Temperature = NvidiaNvml_HardwareMonitor_Temperature;
  using MemoryUse = NvidiaNvml_HardwareMonitor_MemoryUse;
  using Power = NvidiaNvml_HardwareMonitor_Power;
  using PCIe = NvidiaNvml_HardwareMonitor_PCIe;

  // accessors -------------------------------------------------------
  enum : int {
    kGpuUtilizationFieldNumber = 1,
    kMemoryUtilizationFieldNumber = 2,
    kTemperatureFieldNumber = 3,
    kMemoryUseFieldNumber = 4,
    kGpuClockFieldNumber = 5,
    kMemoryClockFieldNumber = 6,
    kSmClockFieldNumber = 7,
    kPowerFieldNumber = 8,
    kPcieFieldNumber = 9,
  };
  // .legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue gpu_utilization = 1;
  bool has_gpu_utilization() const;
  void clear_gpu_utilization() ;
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& gpu_utilization() const;
  [[nodiscard]] ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE release_gpu_utilization();
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL mutable_gpu_utilization();
  void set_allocated_gpu_utilization(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gpu_utilization(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE unsafe_arena_release_gpu_utilization();

  private:
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& _internal_gpu_utilization() const;
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL _internal_mutable_gpu_utilization();

  public:
  // .legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue memory_utilization = 2;
  bool has_memory_utilization() const;
  void clear_memory_utilization() ;
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& memory_utilization() const;
  [[nodiscard]] ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE release_memory_utilization();
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL mutable_memory_utilization();
  void set_allocated_memory_utilization(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_memory_utilization(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE unsafe_arena_release_memory_utilization();

  private:
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& _internal_memory_utilization() const;
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL _internal_mutable_memory_utilization();

  public:
  // .legion.messages.NvidiaNvml.HardwareMonitor.Temperature temperature = 3;
  bool has_temperature() const;
  void clear_temperature() ;
  const ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature& temperature() const;
  [[nodiscard]] ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NULLABLE release_temperature();
  ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NONNULL mutable_temperature();
  void set_allocated_temperature(::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_temperature(::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NULLABLE value);
  ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NULLABLE unsafe_arena_release_temperature();

  private:
  const ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature& _internal_temperature() const;
  ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NONNULL _internal_mutable_temperature();

  public:
  // .legion.messages.NvidiaNvml.HardwareMonitor.MemoryUse memory_use = 4;
  bool has_memory_use() const;
  void clear_memory_use() ;
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse& memory_use() const;
  [[nodiscard]] ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NULLABLE release_memory_use();
  ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NONNULL mutable_memory_use();
  void set_allocated_memory_use(::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_memory_use(::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NULLABLE value);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NULLABLE unsafe_arena_release_memory_use();

  private:
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse& _internal_memory_use() const;
  ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NONNULL _internal_mutable_memory_use();

  public:
  // .legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue gpu_clock = 5;
  bool has_gpu_clock() const;
  void clear_gpu_clock() ;
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& gpu_clock() const;
  [[nodiscard]] ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE release_gpu_clock();
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL mutable_gpu_clock();
  void set_allocated_gpu_clock(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gpu_clock(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE unsafe_arena_release_gpu_clock();

  private:
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& _internal_gpu_clock() const;
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL _internal_mutable_gpu_clock();

  public:
  // .legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue memory_clock = 6;
  bool has_memory_clock() const;
  void clear_memory_clock() ;
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& memory_clock() const;
  [[nodiscard]] ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE release_memory_clock();
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL mutable_memory_clock();
  void set_allocated_memory_clock(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_memory_clock(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE unsafe_arena_release_memory_clock();

  private:
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& _internal_memory_clock() const;
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL _internal_mutable_memory_clock();

  public:
  // .legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue sm_clock = 7;
  bool has_sm_clock() const;
  void clear_sm_clock() ;
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& sm_clock() const;
  [[nodiscard]] ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE release_sm_clock();
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL mutable_sm_clock();
  void set_allocated_sm_clock(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sm_clock(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE unsafe_arena_release_sm_clock();

  private:
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& _internal_sm_clock() const;
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL _internal_mutable_sm_clock();

  public:
  // .legion.messages.NvidiaNvml.HardwareMonitor.Power power = 8;
  bool has_power() const;
  void clear_power() ;
  const ::legion::messages::NvidiaNvml_HardwareMonitor_Power& power() const;
  [[nodiscard]] ::legion::messages::NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NULLABLE release_power();
  ::legion::messages::NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NONNULL mutable_power();
  void set_allocated_power(::legion::messages::NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_power(::legion::messages::NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NULLABLE value);
  ::legion::messages::NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NULLABLE unsafe_arena_release_power();

  private:
  const ::legion::messages::NvidiaNvml_HardwareMonitor_Power& _internal_power() const;
  ::legion::messages::NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NONNULL _internal_mutable_power();

  public:
  // .legion.messages.NvidiaNvml.HardwareMonitor.PCIe pcie = 9;
  bool has_pcie() const;
  void clear_pcie() ;
  const ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe& pcie() const;
  [[nodiscard]] ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NULLABLE release_pcie();
  ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NONNULL mutable_pcie();
  void set_allocated_pcie(::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pcie(::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NULLABLE value);
  ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NULLABLE unsafe_arena_release_pcie();

  private:
  const ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe& _internal_pcie() const;
  ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NONNULL _internal_mutable_pcie();

  public:
  // @@protoc_insertion_point(class_scope:legion.messages.NvidiaNvml.HardwareMonitor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   9, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NvidiaNvml_HardwareMonitor& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE gpu_utilization_;
    ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE memory_utilization_;
    ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NULLABLE temperature_;
    ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NULLABLE memory_use_;
    ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE gpu_clock_;
    ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE memory_clock_;
    ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE sm_clock_;
    ::legion::messages::NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NULLABLE power_;
    ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NULLABLE pcie_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_NvidiaNvml_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_HardwareMonitor_class_data_;
// -------------------------------------------------------------------

class NvidiaNvml final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:legion.messages.NvidiaNvml) */ {
 public:
  inline NvidiaNvml() : NvidiaNvml(nullptr) {}
  ~NvidiaNvml() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NvidiaNvml* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NvidiaNvml));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NvidiaNvml(::google::protobuf::internal::ConstantInitialized);

  inline NvidiaNvml(const NvidiaNvml& from) : NvidiaNvml(nullptr, from) {}
  inline NvidiaNvml(NvidiaNvml&& from) noexcept
      : NvidiaNvml(nullptr, ::std::move(from)) {}
  inline NvidiaNvml& operator=(const NvidiaNvml& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvidiaNvml& operator=(NvidiaNvml&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvidiaNvml& default_instance() {
    return *reinterpret_cast<const NvidiaNvml*>(
        &_NvidiaNvml_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(NvidiaNvml& a, NvidiaNvml& b) { a.Swap(&b); }
  inline void Swap(NvidiaNvml* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvidiaNvml* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvidiaNvml* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NvidiaNvml>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NvidiaNvml& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NvidiaNvml& from) { NvidiaNvml::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NvidiaNvml* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "legion.messages.NvidiaNvml"; }

  explicit NvidiaNvml(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NvidiaNvml(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NvidiaNvml& from);
  NvidiaNvml(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NvidiaNvml&& from) noexcept
      : NvidiaNvml(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using HardwareMonitor = NvidiaNvml_HardwareMonitor;
  using OffsetSettings = NvidiaNvml_OffsetSettings;

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 4,
    kHardwareMonitorFieldNumber = 1,
    kGpuOffsetFieldNumber = 2,
    kMemoryOffsetFieldNumber = 3,
  };
  // string name = 4;
  bool has_name() const;
  void clear_name() ;
  ::absl::string_view name() const;
  template <typename Arg_ = ::std::string&&>
  void set_name(Arg_&& arg);

  private:
  ::absl::string_view _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(::absl::string_view value);

  public:
  // .legion.messages.NvidiaNvml.HardwareMonitor hardware_monitor = 1;
  bool has_hardware_monitor() const;
  void clear_hardware_monitor() ;
  const ::legion::messages::NvidiaNvml_HardwareMonitor& hardware_monitor() const;
  [[nodiscard]] ::legion::messages::NvidiaNvml_HardwareMonitor* PROTOBUF_NULLABLE release_hardware_monitor();
  ::legion::messages::NvidiaNvml_HardwareMonitor* PROTOBUF_NONNULL mutable_hardware_monitor();
  void set_allocated_hardware_monitor(::legion::messages::NvidiaNvml_HardwareMonitor* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hardware_monitor(::legion::messages::NvidiaNvml_HardwareMonitor* PROTOBUF_NULLABLE value);
  ::legion::messages::NvidiaNvml_HardwareMonitor* PROTOBUF_NULLABLE unsafe_arena_release_hardware_monitor();

  private:
  const ::legion::messages::NvidiaNvml_HardwareMonitor& _internal_hardware_monitor() const;
  ::legion::messages::NvidiaNvml_HardwareMonitor* PROTOBUF_NONNULL _internal_mutable_hardware_monitor();

  public:
  // .legion.messages.NvidiaNvml.OffsetSettings gpu_offset = 2;
  bool has_gpu_offset() const;
  void clear_gpu_offset() ;
  const ::legion::messages::NvidiaNvml_OffsetSettings& gpu_offset() const;
  [[nodiscard]] ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE release_gpu_offset();
  ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NONNULL mutable_gpu_offset();
  void set_allocated_gpu_offset(::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gpu_offset(::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE value);
  ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE unsafe_arena_release_gpu_offset();

  private:
  const ::legion::messages::NvidiaNvml_OffsetSettings& _internal_gpu_offset() const;
  ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NONNULL _internal_mutable_gpu_offset();

  public:
  // .legion.messages.NvidiaNvml.OffsetSettings memory_offset = 3;
  bool has_memory_offset() const;
  void clear_memory_offset() ;
  const ::legion::messages::NvidiaNvml_OffsetSettings& memory_offset() const;
  [[nodiscard]] ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE release_memory_offset();
  ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NONNULL mutable_memory_offset();
  void set_allocated_memory_offset(::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_memory_offset(::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE value);
  ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE unsafe_arena_release_memory_offset();

  private:
  const ::legion::messages::NvidiaNvml_OffsetSettings& _internal_memory_offset() const;
  ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NONNULL _internal_mutable_memory_offset();

  public:
  // @@protoc_insertion_point(class_scope:legion.messages.NvidiaNvml)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   3, 39,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NvidiaNvml& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::legion::messages::NvidiaNvml_HardwareMonitor* PROTOBUF_NULLABLE hardware_monitor_;
    ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE gpu_offset_;
    ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE memory_offset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_NvidiaNvml_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NvidiaNvml_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NvidiaNvml_HardwareMonitor_MinMaxValue

// uint32 value = 1;
inline bool NvidiaNvml_HardwareMonitor_MinMaxValue::has_value() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_MinMaxValue::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_MinMaxValue::value() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue.value)
  return _internal_value();
}
inline void NvidiaNvml_HardwareMonitor_MinMaxValue::set_value(::uint32_t value) {
  _internal_set_value(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue.value)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_MinMaxValue::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void NvidiaNvml_HardwareMonitor_MinMaxValue::_internal_set_value(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// uint32 min_value = 2;
inline bool NvidiaNvml_HardwareMonitor_MinMaxValue::has_min_value() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_MinMaxValue::clear_min_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_value_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_MinMaxValue::min_value() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue.min_value)
  return _internal_min_value();
}
inline void NvidiaNvml_HardwareMonitor_MinMaxValue::set_min_value(::uint32_t value) {
  _internal_set_min_value(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue.min_value)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_MinMaxValue::_internal_min_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_value_;
}
inline void NvidiaNvml_HardwareMonitor_MinMaxValue::_internal_set_min_value(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_value_ = value;
}

// uint32 max_value = 3;
inline bool NvidiaNvml_HardwareMonitor_MinMaxValue::has_max_value() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_MinMaxValue::clear_max_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_value_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_MinMaxValue::max_value() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue.max_value)
  return _internal_max_value();
}
inline void NvidiaNvml_HardwareMonitor_MinMaxValue::set_max_value(::uint32_t value) {
  _internal_set_max_value(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue.max_value)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_MinMaxValue::_internal_max_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_value_;
}
inline void NvidiaNvml_HardwareMonitor_MinMaxValue::_internal_set_max_value(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_value_ = value;
}

// -------------------------------------------------------------------

// NvidiaNvml_HardwareMonitor_Temperature

// uint32 value = 1;
inline bool NvidiaNvml_HardwareMonitor_Temperature::has_value() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_Temperature::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Temperature::value() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.Temperature.value)
  return _internal_value();
}
inline void NvidiaNvml_HardwareMonitor_Temperature::set_value(::uint32_t value) {
  _internal_set_value(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.Temperature.value)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Temperature::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void NvidiaNvml_HardwareMonitor_Temperature::_internal_set_value(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// uint32 slowdown = 3;
inline bool NvidiaNvml_HardwareMonitor_Temperature::has_slowdown() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_Temperature::clear_slowdown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slowdown_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Temperature::slowdown() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.Temperature.slowdown)
  return _internal_slowdown();
}
inline void NvidiaNvml_HardwareMonitor_Temperature::set_slowdown(::uint32_t value) {
  _internal_set_slowdown(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.Temperature.slowdown)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Temperature::_internal_slowdown() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slowdown_;
}
inline void NvidiaNvml_HardwareMonitor_Temperature::_internal_set_slowdown(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slowdown_ = value;
}

// uint32 shutdown = 4;
inline bool NvidiaNvml_HardwareMonitor_Temperature::has_shutdown() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_Temperature::clear_shutdown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shutdown_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Temperature::shutdown() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.Temperature.shutdown)
  return _internal_shutdown();
}
inline void NvidiaNvml_HardwareMonitor_Temperature::set_shutdown(::uint32_t value) {
  _internal_set_shutdown(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.Temperature.shutdown)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Temperature::_internal_shutdown() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shutdown_;
}
inline void NvidiaNvml_HardwareMonitor_Temperature::_internal_set_shutdown(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shutdown_ = value;
}

// -------------------------------------------------------------------

// NvidiaNvml_HardwareMonitor_MemoryUse

// uint64 used = 1;
inline bool NvidiaNvml_HardwareMonitor_MemoryUse::has_used() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_MemoryUse::clear_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.used_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint64_t NvidiaNvml_HardwareMonitor_MemoryUse::used() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.MemoryUse.used)
  return _internal_used();
}
inline void NvidiaNvml_HardwareMonitor_MemoryUse::set_used(::uint64_t value) {
  _internal_set_used(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.MemoryUse.used)
}
inline ::uint64_t NvidiaNvml_HardwareMonitor_MemoryUse::_internal_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.used_;
}
inline void NvidiaNvml_HardwareMonitor_MemoryUse::_internal_set_used(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.used_ = value;
}

// uint64 total = 2;
inline bool NvidiaNvml_HardwareMonitor_MemoryUse::has_total() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_MemoryUse::clear_total() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint64_t NvidiaNvml_HardwareMonitor_MemoryUse::total() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.MemoryUse.total)
  return _internal_total();
}
inline void NvidiaNvml_HardwareMonitor_MemoryUse::set_total(::uint64_t value) {
  _internal_set_total(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.MemoryUse.total)
}
inline ::uint64_t NvidiaNvml_HardwareMonitor_MemoryUse::_internal_total() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_;
}
inline void NvidiaNvml_HardwareMonitor_MemoryUse::_internal_set_total(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_ = value;
}

// uint64 free = 3;
inline bool NvidiaNvml_HardwareMonitor_MemoryUse::has_free() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_MemoryUse::clear_free() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint64_t NvidiaNvml_HardwareMonitor_MemoryUse::free() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.MemoryUse.free)
  return _internal_free();
}
inline void NvidiaNvml_HardwareMonitor_MemoryUse::set_free(::uint64_t value) {
  _internal_set_free(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.MemoryUse.free)
}
inline ::uint64_t NvidiaNvml_HardwareMonitor_MemoryUse::_internal_free() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.free_;
}
inline void NvidiaNvml_HardwareMonitor_MemoryUse::_internal_set_free(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_ = value;
}

// -------------------------------------------------------------------

// NvidiaNvml_HardwareMonitor_Power

// uint32 value = 1;
inline bool NvidiaNvml_HardwareMonitor_Power::has_value() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_Power::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Power::value() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.Power.value)
  return _internal_value();
}
inline void NvidiaNvml_HardwareMonitor_Power::set_value(::uint32_t value) {
  _internal_set_value(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.Power.value)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Power::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void NvidiaNvml_HardwareMonitor_Power::_internal_set_value(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// uint32 min_value = 2;
inline bool NvidiaNvml_HardwareMonitor_Power::has_min_value() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_Power::clear_min_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_value_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Power::min_value() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.Power.min_value)
  return _internal_min_value();
}
inline void NvidiaNvml_HardwareMonitor_Power::set_min_value(::uint32_t value) {
  _internal_set_min_value(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.Power.min_value)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Power::_internal_min_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_value_;
}
inline void NvidiaNvml_HardwareMonitor_Power::_internal_set_min_value(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_value_ = value;
}

// uint32 max_value = 3;
inline bool NvidiaNvml_HardwareMonitor_Power::has_max_value() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_Power::clear_max_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_value_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Power::max_value() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.Power.max_value)
  return _internal_max_value();
}
inline void NvidiaNvml_HardwareMonitor_Power::set_max_value(::uint32_t value) {
  _internal_set_max_value(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.Power.max_value)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Power::_internal_max_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_value_;
}
inline void NvidiaNvml_HardwareMonitor_Power::_internal_set_max_value(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_value_ = value;
}

// uint32 default_value = 4;
inline bool NvidiaNvml_HardwareMonitor_Power::has_default_value() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_Power::clear_default_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_value_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Power::default_value() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.Power.default_value)
  return _internal_default_value();
}
inline void NvidiaNvml_HardwareMonitor_Power::set_default_value(::uint32_t value) {
  _internal_set_default_value(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.Power.default_value)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Power::_internal_default_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.default_value_;
}
inline void NvidiaNvml_HardwareMonitor_Power::_internal_set_default_value(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_value_ = value;
}

// uint32 enforced_value = 5;
inline bool NvidiaNvml_HardwareMonitor_Power::has_enforced_value() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_Power::clear_enforced_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enforced_value_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Power::enforced_value() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.Power.enforced_value)
  return _internal_enforced_value();
}
inline void NvidiaNvml_HardwareMonitor_Power::set_enforced_value(::uint32_t value) {
  _internal_set_enforced_value(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.Power.enforced_value)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_Power::_internal_enforced_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enforced_value_;
}
inline void NvidiaNvml_HardwareMonitor_Power::_internal_set_enforced_value(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enforced_value_ = value;
}

// uint64 total = 6;
inline bool NvidiaNvml_HardwareMonitor_Power::has_total() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_Power::clear_total() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint64_t NvidiaNvml_HardwareMonitor_Power::total() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.Power.total)
  return _internal_total();
}
inline void NvidiaNvml_HardwareMonitor_Power::set_total(::uint64_t value) {
  _internal_set_total(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.Power.total)
}
inline ::uint64_t NvidiaNvml_HardwareMonitor_Power::_internal_total() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_;
}
inline void NvidiaNvml_HardwareMonitor_Power::_internal_set_total(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_ = value;
}

// -------------------------------------------------------------------

// NvidiaNvml_HardwareMonitor_PCIe

// uint32 generation = 1;
inline bool NvidiaNvml_HardwareMonitor_PCIe::has_generation() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_PCIe::clear_generation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.generation_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_PCIe::generation() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.PCIe.generation)
  return _internal_generation();
}
inline void NvidiaNvml_HardwareMonitor_PCIe::set_generation(::uint32_t value) {
  _internal_set_generation(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.PCIe.generation)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_PCIe::_internal_generation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.generation_;
}
inline void NvidiaNvml_HardwareMonitor_PCIe::_internal_set_generation(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.generation_ = value;
}

// uint32 generation_max = 2;
inline bool NvidiaNvml_HardwareMonitor_PCIe::has_generation_max() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_PCIe::clear_generation_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.generation_max_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_PCIe::generation_max() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.PCIe.generation_max)
  return _internal_generation_max();
}
inline void NvidiaNvml_HardwareMonitor_PCIe::set_generation_max(::uint32_t value) {
  _internal_set_generation_max(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.PCIe.generation_max)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_PCIe::_internal_generation_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.generation_max_;
}
inline void NvidiaNvml_HardwareMonitor_PCIe::_internal_set_generation_max(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.generation_max_ = value;
}

// uint32 width = 3;
inline bool NvidiaNvml_HardwareMonitor_PCIe::has_width() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_PCIe::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_PCIe::width() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.PCIe.width)
  return _internal_width();
}
inline void NvidiaNvml_HardwareMonitor_PCIe::set_width(::uint32_t value) {
  _internal_set_width(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.PCIe.width)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_PCIe::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void NvidiaNvml_HardwareMonitor_PCIe::_internal_set_width(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// uint32 width_max = 4;
inline bool NvidiaNvml_HardwareMonitor_PCIe::has_width_max() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_PCIe::clear_width_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_max_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_PCIe::width_max() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.PCIe.width_max)
  return _internal_width_max();
}
inline void NvidiaNvml_HardwareMonitor_PCIe::set_width_max(::uint32_t value) {
  _internal_set_width_max(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.PCIe.width_max)
}
inline ::uint32_t NvidiaNvml_HardwareMonitor_PCIe::_internal_width_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_max_;
}
inline void NvidiaNvml_HardwareMonitor_PCIe::_internal_set_width_max(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_max_ = value;
}

// uint64 rx_bytes = 5;
inline bool NvidiaNvml_HardwareMonitor_PCIe::has_rx_bytes() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_PCIe::clear_rx_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rx_bytes_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint64_t NvidiaNvml_HardwareMonitor_PCIe::rx_bytes() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.PCIe.rx_bytes)
  return _internal_rx_bytes();
}
inline void NvidiaNvml_HardwareMonitor_PCIe::set_rx_bytes(::uint64_t value) {
  _internal_set_rx_bytes(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.PCIe.rx_bytes)
}
inline ::uint64_t NvidiaNvml_HardwareMonitor_PCIe::_internal_rx_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rx_bytes_;
}
inline void NvidiaNvml_HardwareMonitor_PCIe::_internal_set_rx_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rx_bytes_ = value;
}

// uint64 tx_bytes = 6;
inline bool NvidiaNvml_HardwareMonitor_PCIe::has_tx_bytes() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void NvidiaNvml_HardwareMonitor_PCIe::clear_tx_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tx_bytes_ = ::uint64_t{0u};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::uint64_t NvidiaNvml_HardwareMonitor_PCIe::tx_bytes() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.PCIe.tx_bytes)
  return _internal_tx_bytes();
}
inline void NvidiaNvml_HardwareMonitor_PCIe::set_tx_bytes(::uint64_t value) {
  _internal_set_tx_bytes(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.HardwareMonitor.PCIe.tx_bytes)
}
inline ::uint64_t NvidiaNvml_HardwareMonitor_PCIe::_internal_tx_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tx_bytes_;
}
inline void NvidiaNvml_HardwareMonitor_PCIe::_internal_set_tx_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tx_bytes_ = value;
}

// -------------------------------------------------------------------

// NvidiaNvml_HardwareMonitor

// .legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue gpu_utilization = 1;
inline bool NvidiaNvml_HardwareMonitor::has_gpu_utilization() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.gpu_utilization_ != nullptr);
  return value;
}
inline void NvidiaNvml_HardwareMonitor::clear_gpu_utilization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gpu_utilization_ != nullptr) _impl_.gpu_utilization_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& NvidiaNvml_HardwareMonitor::_internal_gpu_utilization() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* p = _impl_.gpu_utilization_;
  return p != nullptr ? *p : reinterpret_cast<const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue&>(::legion::messages::_NvidiaNvml_HardwareMonitor_MinMaxValue_default_instance_);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& NvidiaNvml_HardwareMonitor::gpu_utilization() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.gpu_utilization)
  return _internal_gpu_utilization();
}
inline void NvidiaNvml_HardwareMonitor::unsafe_arena_set_allocated_gpu_utilization(
    ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gpu_utilization_);
  }
  _impl_.gpu_utilization_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.gpu_utilization)
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::release_gpu_utilization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* released = _impl_.gpu_utilization_;
  _impl_.gpu_utilization_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::unsafe_arena_release_gpu_utilization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:legion.messages.NvidiaNvml.HardwareMonitor.gpu_utilization)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* temp = _impl_.gpu_utilization_;
  _impl_.gpu_utilization_ = nullptr;
  return temp;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::_internal_mutable_gpu_utilization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gpu_utilization_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue>(GetArena());
    _impl_.gpu_utilization_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(p);
  }
  return _impl_.gpu_utilization_;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::mutable_gpu_utilization()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* _msg = _internal_mutable_gpu_utilization();
  // @@protoc_insertion_point(field_mutable:legion.messages.NvidiaNvml.HardwareMonitor.gpu_utilization)
  return _msg;
}
inline void NvidiaNvml_HardwareMonitor::set_allocated_gpu_utilization(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gpu_utilization_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.gpu_utilization_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.gpu_utilization)
}

// .legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue memory_utilization = 2;
inline bool NvidiaNvml_HardwareMonitor::has_memory_utilization() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.memory_utilization_ != nullptr);
  return value;
}
inline void NvidiaNvml_HardwareMonitor::clear_memory_utilization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.memory_utilization_ != nullptr) _impl_.memory_utilization_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& NvidiaNvml_HardwareMonitor::_internal_memory_utilization() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* p = _impl_.memory_utilization_;
  return p != nullptr ? *p : reinterpret_cast<const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue&>(::legion::messages::_NvidiaNvml_HardwareMonitor_MinMaxValue_default_instance_);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& NvidiaNvml_HardwareMonitor::memory_utilization() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.memory_utilization)
  return _internal_memory_utilization();
}
inline void NvidiaNvml_HardwareMonitor::unsafe_arena_set_allocated_memory_utilization(
    ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.memory_utilization_);
  }
  _impl_.memory_utilization_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.memory_utilization)
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::release_memory_utilization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* released = _impl_.memory_utilization_;
  _impl_.memory_utilization_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::unsafe_arena_release_memory_utilization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:legion.messages.NvidiaNvml.HardwareMonitor.memory_utilization)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* temp = _impl_.memory_utilization_;
  _impl_.memory_utilization_ = nullptr;
  return temp;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::_internal_mutable_memory_utilization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.memory_utilization_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue>(GetArena());
    _impl_.memory_utilization_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(p);
  }
  return _impl_.memory_utilization_;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::mutable_memory_utilization()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* _msg = _internal_mutable_memory_utilization();
  // @@protoc_insertion_point(field_mutable:legion.messages.NvidiaNvml.HardwareMonitor.memory_utilization)
  return _msg;
}
inline void NvidiaNvml_HardwareMonitor::set_allocated_memory_utilization(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.memory_utilization_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.memory_utilization_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.memory_utilization)
}

// .legion.messages.NvidiaNvml.HardwareMonitor.Temperature temperature = 3;
inline bool NvidiaNvml_HardwareMonitor::has_temperature() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.temperature_ != nullptr);
  return value;
}
inline void NvidiaNvml_HardwareMonitor::clear_temperature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.temperature_ != nullptr) _impl_.temperature_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature& NvidiaNvml_HardwareMonitor::_internal_temperature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* p = _impl_.temperature_;
  return p != nullptr ? *p : reinterpret_cast<const ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature&>(::legion::messages::_NvidiaNvml_HardwareMonitor_Temperature_default_instance_);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature& NvidiaNvml_HardwareMonitor::temperature() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.temperature)
  return _internal_temperature();
}
inline void NvidiaNvml_HardwareMonitor::unsafe_arena_set_allocated_temperature(
    ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.temperature_);
  }
  _impl_.temperature_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_Temperature*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.temperature)
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::release_temperature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* released = _impl_.temperature_;
  _impl_.temperature_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::unsafe_arena_release_temperature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:legion.messages.NvidiaNvml.HardwareMonitor.temperature)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* temp = _impl_.temperature_;
  _impl_.temperature_ = nullptr;
  return temp;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::_internal_mutable_temperature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.temperature_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::legion::messages::NvidiaNvml_HardwareMonitor_Temperature>(GetArena());
    _impl_.temperature_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_Temperature*>(p);
  }
  return _impl_.temperature_;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::mutable_temperature()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* _msg = _internal_mutable_temperature();
  // @@protoc_insertion_point(field_mutable:legion.messages.NvidiaNvml.HardwareMonitor.temperature)
  return _msg;
}
inline void NvidiaNvml_HardwareMonitor::set_allocated_temperature(::legion::messages::NvidiaNvml_HardwareMonitor_Temperature* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.temperature_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.temperature_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_Temperature*>(value);
  // @@protoc_insertion_point(field_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.temperature)
}

// .legion.messages.NvidiaNvml.HardwareMonitor.MemoryUse memory_use = 4;
inline bool NvidiaNvml_HardwareMonitor::has_memory_use() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.memory_use_ != nullptr);
  return value;
}
inline void NvidiaNvml_HardwareMonitor::clear_memory_use() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.memory_use_ != nullptr) _impl_.memory_use_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse& NvidiaNvml_HardwareMonitor::_internal_memory_use() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* p = _impl_.memory_use_;
  return p != nullptr ? *p : reinterpret_cast<const ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse&>(::legion::messages::_NvidiaNvml_HardwareMonitor_MemoryUse_default_instance_);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse& NvidiaNvml_HardwareMonitor::memory_use() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.memory_use)
  return _internal_memory_use();
}
inline void NvidiaNvml_HardwareMonitor::unsafe_arena_set_allocated_memory_use(
    ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.memory_use_);
  }
  _impl_.memory_use_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.memory_use)
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::release_memory_use() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* released = _impl_.memory_use_;
  _impl_.memory_use_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::unsafe_arena_release_memory_use() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:legion.messages.NvidiaNvml.HardwareMonitor.memory_use)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* temp = _impl_.memory_use_;
  _impl_.memory_use_ = nullptr;
  return temp;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::_internal_mutable_memory_use() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.memory_use_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse>(GetArena());
    _impl_.memory_use_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse*>(p);
  }
  return _impl_.memory_use_;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::mutable_memory_use()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* _msg = _internal_mutable_memory_use();
  // @@protoc_insertion_point(field_mutable:legion.messages.NvidiaNvml.HardwareMonitor.memory_use)
  return _msg;
}
inline void NvidiaNvml_HardwareMonitor::set_allocated_memory_use(::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.memory_use_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.memory_use_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MemoryUse*>(value);
  // @@protoc_insertion_point(field_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.memory_use)
}

// .legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue gpu_clock = 5;
inline bool NvidiaNvml_HardwareMonitor::has_gpu_clock() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.gpu_clock_ != nullptr);
  return value;
}
inline void NvidiaNvml_HardwareMonitor::clear_gpu_clock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gpu_clock_ != nullptr) _impl_.gpu_clock_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& NvidiaNvml_HardwareMonitor::_internal_gpu_clock() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* p = _impl_.gpu_clock_;
  return p != nullptr ? *p : reinterpret_cast<const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue&>(::legion::messages::_NvidiaNvml_HardwareMonitor_MinMaxValue_default_instance_);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& NvidiaNvml_HardwareMonitor::gpu_clock() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.gpu_clock)
  return _internal_gpu_clock();
}
inline void NvidiaNvml_HardwareMonitor::unsafe_arena_set_allocated_gpu_clock(
    ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gpu_clock_);
  }
  _impl_.gpu_clock_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.gpu_clock)
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::release_gpu_clock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* released = _impl_.gpu_clock_;
  _impl_.gpu_clock_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::unsafe_arena_release_gpu_clock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:legion.messages.NvidiaNvml.HardwareMonitor.gpu_clock)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* temp = _impl_.gpu_clock_;
  _impl_.gpu_clock_ = nullptr;
  return temp;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::_internal_mutable_gpu_clock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gpu_clock_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue>(GetArena());
    _impl_.gpu_clock_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(p);
  }
  return _impl_.gpu_clock_;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::mutable_gpu_clock()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* _msg = _internal_mutable_gpu_clock();
  // @@protoc_insertion_point(field_mutable:legion.messages.NvidiaNvml.HardwareMonitor.gpu_clock)
  return _msg;
}
inline void NvidiaNvml_HardwareMonitor::set_allocated_gpu_clock(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gpu_clock_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.gpu_clock_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.gpu_clock)
}

// .legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue memory_clock = 6;
inline bool NvidiaNvml_HardwareMonitor::has_memory_clock() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.memory_clock_ != nullptr);
  return value;
}
inline void NvidiaNvml_HardwareMonitor::clear_memory_clock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.memory_clock_ != nullptr) _impl_.memory_clock_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& NvidiaNvml_HardwareMonitor::_internal_memory_clock() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* p = _impl_.memory_clock_;
  return p != nullptr ? *p : reinterpret_cast<const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue&>(::legion::messages::_NvidiaNvml_HardwareMonitor_MinMaxValue_default_instance_);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& NvidiaNvml_HardwareMonitor::memory_clock() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.memory_clock)
  return _internal_memory_clock();
}
inline void NvidiaNvml_HardwareMonitor::unsafe_arena_set_allocated_memory_clock(
    ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.memory_clock_);
  }
  _impl_.memory_clock_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.memory_clock)
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::release_memory_clock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* released = _impl_.memory_clock_;
  _impl_.memory_clock_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::unsafe_arena_release_memory_clock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:legion.messages.NvidiaNvml.HardwareMonitor.memory_clock)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* temp = _impl_.memory_clock_;
  _impl_.memory_clock_ = nullptr;
  return temp;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::_internal_mutable_memory_clock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.memory_clock_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue>(GetArena());
    _impl_.memory_clock_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(p);
  }
  return _impl_.memory_clock_;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::mutable_memory_clock()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* _msg = _internal_mutable_memory_clock();
  // @@protoc_insertion_point(field_mutable:legion.messages.NvidiaNvml.HardwareMonitor.memory_clock)
  return _msg;
}
inline void NvidiaNvml_HardwareMonitor::set_allocated_memory_clock(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.memory_clock_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.memory_clock_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.memory_clock)
}

// .legion.messages.NvidiaNvml.HardwareMonitor.MinMaxValue sm_clock = 7;
inline bool NvidiaNvml_HardwareMonitor::has_sm_clock() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.sm_clock_ != nullptr);
  return value;
}
inline void NvidiaNvml_HardwareMonitor::clear_sm_clock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sm_clock_ != nullptr) _impl_.sm_clock_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& NvidiaNvml_HardwareMonitor::_internal_sm_clock() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* p = _impl_.sm_clock_;
  return p != nullptr ? *p : reinterpret_cast<const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue&>(::legion::messages::_NvidiaNvml_HardwareMonitor_MinMaxValue_default_instance_);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue& NvidiaNvml_HardwareMonitor::sm_clock() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.sm_clock)
  return _internal_sm_clock();
}
inline void NvidiaNvml_HardwareMonitor::unsafe_arena_set_allocated_sm_clock(
    ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sm_clock_);
  }
  _impl_.sm_clock_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.sm_clock)
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::release_sm_clock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* released = _impl_.sm_clock_;
  _impl_.sm_clock_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::unsafe_arena_release_sm_clock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:legion.messages.NvidiaNvml.HardwareMonitor.sm_clock)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* temp = _impl_.sm_clock_;
  _impl_.sm_clock_ = nullptr;
  return temp;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::_internal_mutable_sm_clock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sm_clock_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue>(GetArena());
    _impl_.sm_clock_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(p);
  }
  return _impl_.sm_clock_;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::mutable_sm_clock()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* _msg = _internal_mutable_sm_clock();
  // @@protoc_insertion_point(field_mutable:legion.messages.NvidiaNvml.HardwareMonitor.sm_clock)
  return _msg;
}
inline void NvidiaNvml_HardwareMonitor::set_allocated_sm_clock(::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sm_clock_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.sm_clock_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_MinMaxValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.sm_clock)
}

// .legion.messages.NvidiaNvml.HardwareMonitor.Power power = 8;
inline bool NvidiaNvml_HardwareMonitor::has_power() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  PROTOBUF_ASSUME(!value || _impl_.power_ != nullptr);
  return value;
}
inline void NvidiaNvml_HardwareMonitor::clear_power() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.power_ != nullptr) _impl_.power_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_Power& NvidiaNvml_HardwareMonitor::_internal_power() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::legion::messages::NvidiaNvml_HardwareMonitor_Power* p = _impl_.power_;
  return p != nullptr ? *p : reinterpret_cast<const ::legion::messages::NvidiaNvml_HardwareMonitor_Power&>(::legion::messages::_NvidiaNvml_HardwareMonitor_Power_default_instance_);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_Power& NvidiaNvml_HardwareMonitor::power() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.power)
  return _internal_power();
}
inline void NvidiaNvml_HardwareMonitor::unsafe_arena_set_allocated_power(
    ::legion::messages::NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.power_);
  }
  _impl_.power_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_Power*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.power)
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::release_power() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_Power* released = _impl_.power_;
  _impl_.power_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::unsafe_arena_release_power() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:legion.messages.NvidiaNvml.HardwareMonitor.power)

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_Power* temp = _impl_.power_;
  _impl_.power_ = nullptr;
  return temp;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::_internal_mutable_power() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.power_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::legion::messages::NvidiaNvml_HardwareMonitor_Power>(GetArena());
    _impl_.power_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_Power*>(p);
  }
  return _impl_.power_;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::mutable_power()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_Power* _msg = _internal_mutable_power();
  // @@protoc_insertion_point(field_mutable:legion.messages.NvidiaNvml.HardwareMonitor.power)
  return _msg;
}
inline void NvidiaNvml_HardwareMonitor::set_allocated_power(::legion::messages::NvidiaNvml_HardwareMonitor_Power* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.power_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }

  _impl_.power_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_Power*>(value);
  // @@protoc_insertion_point(field_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.power)
}

// .legion.messages.NvidiaNvml.HardwareMonitor.PCIe pcie = 9;
inline bool NvidiaNvml_HardwareMonitor::has_pcie() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  PROTOBUF_ASSUME(!value || _impl_.pcie_ != nullptr);
  return value;
}
inline void NvidiaNvml_HardwareMonitor::clear_pcie() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pcie_ != nullptr) _impl_.pcie_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe& NvidiaNvml_HardwareMonitor::_internal_pcie() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* p = _impl_.pcie_;
  return p != nullptr ? *p : reinterpret_cast<const ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe&>(::legion::messages::_NvidiaNvml_HardwareMonitor_PCIe_default_instance_);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe& NvidiaNvml_HardwareMonitor::pcie() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.HardwareMonitor.pcie)
  return _internal_pcie();
}
inline void NvidiaNvml_HardwareMonitor::unsafe_arena_set_allocated_pcie(
    ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pcie_);
  }
  _impl_.pcie_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_PCIe*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.pcie)
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::release_pcie() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* released = _impl_.pcie_;
  _impl_.pcie_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NULLABLE NvidiaNvml_HardwareMonitor::unsafe_arena_release_pcie() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:legion.messages.NvidiaNvml.HardwareMonitor.pcie)

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* temp = _impl_.pcie_;
  _impl_.pcie_ = nullptr;
  return temp;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::_internal_mutable_pcie() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pcie_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::legion::messages::NvidiaNvml_HardwareMonitor_PCIe>(GetArena());
    _impl_.pcie_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_PCIe*>(p);
  }
  return _impl_.pcie_;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NONNULL NvidiaNvml_HardwareMonitor::mutable_pcie()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* _msg = _internal_mutable_pcie();
  // @@protoc_insertion_point(field_mutable:legion.messages.NvidiaNvml.HardwareMonitor.pcie)
  return _msg;
}
inline void NvidiaNvml_HardwareMonitor::set_allocated_pcie(::legion::messages::NvidiaNvml_HardwareMonitor_PCIe* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pcie_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }

  _impl_.pcie_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor_PCIe*>(value);
  // @@protoc_insertion_point(field_set_allocated:legion.messages.NvidiaNvml.HardwareMonitor.pcie)
}

// -------------------------------------------------------------------

// NvidiaNvml_OffsetSettings

// uint32 max = 1;
inline bool NvidiaNvml_OffsetSettings::has_max() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void NvidiaNvml_OffsetSettings::clear_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint32_t NvidiaNvml_OffsetSettings::max() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.OffsetSettings.max)
  return _internal_max();
}
inline void NvidiaNvml_OffsetSettings::set_max(::uint32_t value) {
  _internal_set_max(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.OffsetSettings.max)
}
inline ::uint32_t NvidiaNvml_OffsetSettings::_internal_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_;
}
inline void NvidiaNvml_OffsetSettings::_internal_set_max(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_ = value;
}

// uint32 min = 2;
inline bool NvidiaNvml_OffsetSettings::has_min() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void NvidiaNvml_OffsetSettings::clear_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t NvidiaNvml_OffsetSettings::min() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.OffsetSettings.min)
  return _internal_min();
}
inline void NvidiaNvml_OffsetSettings::set_min(::uint32_t value) {
  _internal_set_min(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.OffsetSettings.min)
}
inline ::uint32_t NvidiaNvml_OffsetSettings::_internal_min() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_;
}
inline void NvidiaNvml_OffsetSettings::_internal_set_min(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_ = value;
}

// int32 value = 3;
inline bool NvidiaNvml_OffsetSettings::has_value() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void NvidiaNvml_OffsetSettings::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t NvidiaNvml_OffsetSettings::value() const {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.OffsetSettings.value)
  return _internal_value();
}
inline void NvidiaNvml_OffsetSettings::set_value(::int32_t value) {
  _internal_set_value(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.OffsetSettings.value)
}
inline ::int32_t NvidiaNvml_OffsetSettings::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void NvidiaNvml_OffsetSettings::_internal_set_value(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// NvidiaNvml

// .legion.messages.NvidiaNvml.HardwareMonitor hardware_monitor = 1;
inline bool NvidiaNvml::has_hardware_monitor() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.hardware_monitor_ != nullptr);
  return value;
}
inline void NvidiaNvml::clear_hardware_monitor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hardware_monitor_ != nullptr) _impl_.hardware_monitor_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor& NvidiaNvml::_internal_hardware_monitor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::legion::messages::NvidiaNvml_HardwareMonitor* p = _impl_.hardware_monitor_;
  return p != nullptr ? *p : reinterpret_cast<const ::legion::messages::NvidiaNvml_HardwareMonitor&>(::legion::messages::_NvidiaNvml_HardwareMonitor_default_instance_);
}
inline const ::legion::messages::NvidiaNvml_HardwareMonitor& NvidiaNvml::hardware_monitor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.hardware_monitor)
  return _internal_hardware_monitor();
}
inline void NvidiaNvml::unsafe_arena_set_allocated_hardware_monitor(
    ::legion::messages::NvidiaNvml_HardwareMonitor* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hardware_monitor_);
  }
  _impl_.hardware_monitor_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:legion.messages.NvidiaNvml.hardware_monitor)
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor* PROTOBUF_NULLABLE NvidiaNvml::release_hardware_monitor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::legion::messages::NvidiaNvml_HardwareMonitor* released = _impl_.hardware_monitor_;
  _impl_.hardware_monitor_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor* PROTOBUF_NULLABLE NvidiaNvml::unsafe_arena_release_hardware_monitor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:legion.messages.NvidiaNvml.hardware_monitor)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::legion::messages::NvidiaNvml_HardwareMonitor* temp = _impl_.hardware_monitor_;
  _impl_.hardware_monitor_ = nullptr;
  return temp;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor* PROTOBUF_NONNULL NvidiaNvml::_internal_mutable_hardware_monitor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hardware_monitor_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::legion::messages::NvidiaNvml_HardwareMonitor>(GetArena());
    _impl_.hardware_monitor_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor*>(p);
  }
  return _impl_.hardware_monitor_;
}
inline ::legion::messages::NvidiaNvml_HardwareMonitor* PROTOBUF_NONNULL NvidiaNvml::mutable_hardware_monitor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::legion::messages::NvidiaNvml_HardwareMonitor* _msg = _internal_mutable_hardware_monitor();
  // @@protoc_insertion_point(field_mutable:legion.messages.NvidiaNvml.hardware_monitor)
  return _msg;
}
inline void NvidiaNvml::set_allocated_hardware_monitor(::legion::messages::NvidiaNvml_HardwareMonitor* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hardware_monitor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.hardware_monitor_ = reinterpret_cast<::legion::messages::NvidiaNvml_HardwareMonitor*>(value);
  // @@protoc_insertion_point(field_set_allocated:legion.messages.NvidiaNvml.hardware_monitor)
}

// .legion.messages.NvidiaNvml.OffsetSettings gpu_offset = 2;
inline bool NvidiaNvml::has_gpu_offset() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.gpu_offset_ != nullptr);
  return value;
}
inline void NvidiaNvml::clear_gpu_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gpu_offset_ != nullptr) _impl_.gpu_offset_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::legion::messages::NvidiaNvml_OffsetSettings& NvidiaNvml::_internal_gpu_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::legion::messages::NvidiaNvml_OffsetSettings* p = _impl_.gpu_offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::legion::messages::NvidiaNvml_OffsetSettings&>(::legion::messages::_NvidiaNvml_OffsetSettings_default_instance_);
}
inline const ::legion::messages::NvidiaNvml_OffsetSettings& NvidiaNvml::gpu_offset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.gpu_offset)
  return _internal_gpu_offset();
}
inline void NvidiaNvml::unsafe_arena_set_allocated_gpu_offset(
    ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gpu_offset_);
  }
  _impl_.gpu_offset_ = reinterpret_cast<::legion::messages::NvidiaNvml_OffsetSettings*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:legion.messages.NvidiaNvml.gpu_offset)
}
inline ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE NvidiaNvml::release_gpu_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::legion::messages::NvidiaNvml_OffsetSettings* released = _impl_.gpu_offset_;
  _impl_.gpu_offset_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE NvidiaNvml::unsafe_arena_release_gpu_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:legion.messages.NvidiaNvml.gpu_offset)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::legion::messages::NvidiaNvml_OffsetSettings* temp = _impl_.gpu_offset_;
  _impl_.gpu_offset_ = nullptr;
  return temp;
}
inline ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NONNULL NvidiaNvml::_internal_mutable_gpu_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gpu_offset_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::legion::messages::NvidiaNvml_OffsetSettings>(GetArena());
    _impl_.gpu_offset_ = reinterpret_cast<::legion::messages::NvidiaNvml_OffsetSettings*>(p);
  }
  return _impl_.gpu_offset_;
}
inline ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NONNULL NvidiaNvml::mutable_gpu_offset()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::legion::messages::NvidiaNvml_OffsetSettings* _msg = _internal_mutable_gpu_offset();
  // @@protoc_insertion_point(field_mutable:legion.messages.NvidiaNvml.gpu_offset)
  return _msg;
}
inline void NvidiaNvml::set_allocated_gpu_offset(::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gpu_offset_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.gpu_offset_ = reinterpret_cast<::legion::messages::NvidiaNvml_OffsetSettings*>(value);
  // @@protoc_insertion_point(field_set_allocated:legion.messages.NvidiaNvml.gpu_offset)
}

// .legion.messages.NvidiaNvml.OffsetSettings memory_offset = 3;
inline bool NvidiaNvml::has_memory_offset() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.memory_offset_ != nullptr);
  return value;
}
inline void NvidiaNvml::clear_memory_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.memory_offset_ != nullptr) _impl_.memory_offset_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::legion::messages::NvidiaNvml_OffsetSettings& NvidiaNvml::_internal_memory_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::legion::messages::NvidiaNvml_OffsetSettings* p = _impl_.memory_offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::legion::messages::NvidiaNvml_OffsetSettings&>(::legion::messages::_NvidiaNvml_OffsetSettings_default_instance_);
}
inline const ::legion::messages::NvidiaNvml_OffsetSettings& NvidiaNvml::memory_offset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.memory_offset)
  return _internal_memory_offset();
}
inline void NvidiaNvml::unsafe_arena_set_allocated_memory_offset(
    ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.memory_offset_);
  }
  _impl_.memory_offset_ = reinterpret_cast<::legion::messages::NvidiaNvml_OffsetSettings*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:legion.messages.NvidiaNvml.memory_offset)
}
inline ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE NvidiaNvml::release_memory_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::legion::messages::NvidiaNvml_OffsetSettings* released = _impl_.memory_offset_;
  _impl_.memory_offset_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE NvidiaNvml::unsafe_arena_release_memory_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:legion.messages.NvidiaNvml.memory_offset)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::legion::messages::NvidiaNvml_OffsetSettings* temp = _impl_.memory_offset_;
  _impl_.memory_offset_ = nullptr;
  return temp;
}
inline ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NONNULL NvidiaNvml::_internal_mutable_memory_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.memory_offset_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::legion::messages::NvidiaNvml_OffsetSettings>(GetArena());
    _impl_.memory_offset_ = reinterpret_cast<::legion::messages::NvidiaNvml_OffsetSettings*>(p);
  }
  return _impl_.memory_offset_;
}
inline ::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NONNULL NvidiaNvml::mutable_memory_offset()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::legion::messages::NvidiaNvml_OffsetSettings* _msg = _internal_mutable_memory_offset();
  // @@protoc_insertion_point(field_mutable:legion.messages.NvidiaNvml.memory_offset)
  return _msg;
}
inline void NvidiaNvml::set_allocated_memory_offset(::legion::messages::NvidiaNvml_OffsetSettings* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.memory_offset_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.memory_offset_ = reinterpret_cast<::legion::messages::NvidiaNvml_OffsetSettings*>(value);
  // @@protoc_insertion_point(field_set_allocated:legion.messages.NvidiaNvml.memory_offset)
}

// string name = 4;
inline bool NvidiaNvml::has_name() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void NvidiaNvml::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::absl::string_view NvidiaNvml::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:legion.messages.NvidiaNvml.name)
  return _internal_name();
}
template <typename Arg_>
PROTOBUF_ALWAYS_INLINE void NvidiaNvml::set_name(Arg_&& arg) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), GetArena());
  // @@protoc_insertion_point(field_set:legion.messages.NvidiaNvml.name)
}
inline ::absl::string_view NvidiaNvml::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void NvidiaNvml::_internal_set_name(::absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.name_.Set(value, GetArena());
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace messages
}  // namespace legion


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // NvidiaNvml_2eproto_2epb_2eh
